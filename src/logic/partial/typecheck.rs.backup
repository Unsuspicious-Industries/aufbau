/// Type checking for partial ASTs
/// 
/// This module provides functionality to check if partial parse alternatives
/// can be typed according to the grammar's typing rules. Alternatives that
/// cannot be typed are filtered out, reducing ambiguity.

use super::*;
use crate::logic::grammar::Grammar;
use crate::logic::typing::TypingRule;

/// Result of type checking an alternative
#[derive(Clone, Debug)]
pub enum TypeCheckResult {
    /// The alternative can be typed (may or may not be complete)
    Typeable,
    /// The alternative cannot be typed (should be filtered out)
    NotTypeable(String),
    /// Type checking not applicable (no typing rule)
    NotApplicable,
}

impl TypeCheckResult {
    pub fn is_typeable(&self) -> bool {
        matches!(self, TypeCheckResult::Typeable | TypeCheckResult::NotApplicable)
    }
}

/// Check if an alternative can be typed according to its typing rule
pub fn check_alt_typeable(alt: &Alt, grammar: &Grammar) -> TypeCheckResult {
    // If no typing rule, consider it typeable (not applicable)
    let Some(rule_name) = &alt.typing_rule else {
        return TypeCheckResult::NotApplicable;
    };
    
    // Look up the typing rule
    let Some(rule) = grammar.typing_rules.get(rule_name) else {
        // Rule referenced but not found - treat as not typeable
        return TypeCheckResult::NotTypeable(format!("typing rule '{}' not found", rule_name));
    };
    
    // For now, we implement a simple check:
    // - If the alternative is incomplete, assume it could be typed (optimistic)
    // - If complete, we would need to actually check the typing rule
    // TODO: Implement full typing rule checking with binding resolution
    
    if !alt.is_complete() {
        // Incomplete alternatives are optimistically typeable
        return TypeCheckResult::Typeable;
    }
    
    // For complete alternatives, try to check the rule
    // This is a placeholder - full implementation would require binding resolution
    check_complete_alt_typeable(alt, rule, grammar)
}

/// Check if a complete alternative satisfies its typing rule
fn check_complete_alt_typeable(alt: &Alt, rule: &TypingRule, grammar: &Grammar) -> TypeCheckResult {
    // Placeholder implementation
    // A full implementation would:
    // 1. Bind the rule to the parsed nodes
    // 2. Check that all premises can be satisfied
    // 3. Verify the conclusion can be derived
    
    // For now, treat complete alternatives with rules as typeable
    // This is optimistic and should be refined
    TypeCheckResult::Typeable
}

/// Filter alternatives in a NonTerminal to keep only typeable ones
pub fn filter_typeable_alternatives(nt: &mut NonTerminal, grammar: &Grammar) {
    nt.alts.retain(|alt| check_alt_typeable(alt, grammar).is_typeable());
}

/// Recursively filter all alternatives in a PartialAST
pub fn filter_typeable_ast(ast: &mut PartialAST, grammar: &Grammar) {
    filter_typeable_nonterminal(&mut ast.root, grammar);
}

/// Recursively filter alternatives in a nonterminal and its children
fn filter_typeable_nonterminal(nt: &mut NonTerminal, grammar: &Grammar) {
    // First filter this nonterminal's alternatives
    filter_typeable_alternatives(nt, grammar);
    
    // Then recursively filter children
    for alt in &mut nt.alts {
        for slot_vec in alt.slots.values_mut() {
            for slot in slot_vec {
                match slot {
                    Slot::Filled(nodes) => {
                        for node in nodes {
                            if let ParsedNode::NonTerminal(child_nt) = node {
                                filter_typeable_nonterminal(child_nt, grammar);
                            }
                        }
                    }
                    Slot::Partial { node: Some(ParsedNode::NonTerminal(child_nt)), .. } => {
                        filter_typeable_nonterminal(child_nt, grammar);
                    }
                    _ => {}
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::logic::partial::parse::Parser;
    
    #[test]
    fn test_filter_keeps_all_when_no_rules() {
        let spec = r#"
        A ::= 'a'
        B ::= 'b'
        start ::= A | B
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        let mut ast = p.partial("").unwrap();
        
        let original_alt_count = ast.root.alts.len();
        filter_typeable_ast(&mut ast, &g);
        
        // Should keep all alternatives since no typing rules
        assert_eq!(ast.root.alts.len(), original_alt_count);
    }
    
    #[test]
    fn test_filter_with_typing_rule() {
        let spec = r#"
        start(var) ::= /[a-z]+/
        
        -------------- (var)
        'int'
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        let ast = p.partial("x").unwrap();
        
        assert!(ast.root.alts.len() > 0, "should have typeable alternative");
    }
    
    #[test]

    
    #[ignore] // TODO: Enable when full type checking is implemented

    
    fn test_incomplete_alternatives_kept() {
        let spec = r#"
        Expr(expr) ::= 'let' /[a-z]+/ '=' /[0-9]+/
        
        -------------- (expr)
        'unit'
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        let mut ast = p.partial("let x").unwrap();
        
        let alt_count_before = ast.root.alts.len();
        filter_typeable_ast(&mut ast, &g);
        
        // Incomplete alternatives should be kept (optimistic)
        // Type filtering is optimistic, incomplete alternatives are kept
        assert!(ast.root.alts.len() > 0, "should have alternatives");
    }
    
    #[test]

    
    #[ignore] // TODO: Enable when full type checking is implemented

    
    fn test_typed_completions_basic() {
        let spec = r#"
        start(num) ::= /[0-9]+/
        
        -------------- (num)
        'int'
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        let ast = p.partial("").unwrap();
        
        let completions = ast.typed_completions(&g);
        assert!(completions.tokens.len() > 0, "should have completions");
    }
    
    #[test]
    fn test_typed_completions_filters_invalid() {
        // This test would need a more sophisticated type checker
        // For now, it demonstrates the API
        let spec = r#"
        Good(good) ::= 'x'
        start ::= Good
        
        -------------- (good)
        'valid'
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        let ast = p.partial("").unwrap();
        
        let typed = ast.typed_completions(&g);
        let untyped = ast.completions(&g);
        
        // For this simple case, should be the same
        assert_eq!(typed.tokens.len(), untyped.tokens.len());
    }
    
    #[test]
    fn test_filter_recursive_nonterminals() {
        let spec = r#"
        Inner(inner) ::= 'a'
        Outer ::= Inner 'b'
        start ::= Outer
        
        -------------- (inner)
        'int'
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        let mut ast = p.partial("a b").unwrap();
        
        // Should filter recursively
        filter_typeable_ast(&mut ast, &g);
        
        // All alternatives should remain (they're all valid)
        assert!(ast.root.alts.len() > 0);
    }
    
    #[test]

    
    #[ignore] // TODO: Enable when full type checking is implemented

    
    fn test_multiple_typing_rules() {
        let spec = r#"
        Var(var) ::= /[a-z]+/
        Num(num) ::= /[0-9]+/
        start ::= Var | Num
        
        -------------- (var)
        'string'
        
        -------------- (num)
        'int'
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        // Parser already filters
        let ast = p.partial("x").unwrap();
        
        // Should keep the Var alternative (it matches)
        assert!(ast.root.alts.len() > 0, "should have alternatives after parsing");
        
        // Check completions are filtered correctly
        let completions = ast.typed_completions(&g);
        assert!(completions.tokens.len() > 0, "should have some completions");
    }
    
    #[test]
    fn test_type_filtering_preserves_valid_alternatives() {
        let spec = r#"
        A(ruleA) ::= 'a'
        B(ruleB) ::= 'b'  
        start ::= A | B
        
        -------------- (ruleA)
        'typeA'
        
        -------------- (ruleB)
        'typeB'
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        // Parser already filters
        let ast = p.partial("").unwrap();
        
        // Both alternatives should be kept (both have valid typing rules)
        // At empty input, we should have alternatives representing the start state
        assert!(ast.root.alts.len() > 0, "should have alternatives");
    }
    
    #[test]
    fn test_typed_completions_with_partial_match() {
        let spec = r#"
        Expr(expr) ::= 'let' /[a-z]+/ '=' /[0-9]+/
        start ::= Expr
        
        -------------- (expr)
        'unit'
        "#;
        
        let g = Grammar::load(spec).unwrap();
        let mut p = Parser::new(g.clone());
        let ast = p.partial("let x =").unwrap();
        
        let completions = ast.typed_completions(&g);
        
        // Should suggest number pattern as next token
        assert!(completions.contains_regex("[0-9]+"), "should suggest number after '='");
    }
}
